Тестовое задание.

* Итеративное считывание и обработку Job-ов. Кол-во goroutine создается по кол-ву Job-ов, но не больше чем 500 на x86 и 5000 на x64.
* Синхронизация доступа к объекту JobObj на самописных spinlock'ах (на atomic).
* Проверка OS/Arch в runtime

Принцип по которому выбиралось кол-во goroutine. Вызов Div происходит через syscall, где вызывается lockOSThread а в самой функции Div - блокирующий вызов Sleep. Поэтому каждая созданная goroutine большую часть времени находится в состоянии привязанной к исполняющему её потоку, который еще и заблокирован. Поэтому планировщик создает новые потоки и в результате на каждую goroutine будет создан свой поток. У потока ОС как минимум есть стек в 1 мб и 500 потоков зарезервируют 500мб - очень много, учитывая что доступно 2гб, и есть еще и загруженные библиотеки, и адресное пространство фрагментированно. Поэтому больше 500 точно не нужно. В x64 адресное пространство огромное и резервировать там можно много, но 5000 потоков используют реальные 200 мб оперативной памяти, что тоже весомо.